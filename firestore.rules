// hooks/useFirestore.js
// UPDATED: Added delete function and 7-day automatic cleanup

import { useState, useEffect, useCallback } from 'react';
import { 
  collection, 
  query, 
  addDoc, 
  deleteDoc,
  doc,
  serverTimestamp, 
  orderBy, 
  onSnapshot,
  where,
  getDocs
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import { EXAM_CONFIGS } from '../config/examConfig';

// App ID from Claude.ai artifact environment
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

export const useFirestore = (user) => {
  const [quizzes, setQuizzes] = useState({});

  // Helper to get user-specific data path
  const getUserDataPath = (collectionName) => {
    const userId = user?.uid || 'anonymous';
    return collection(db, 'artifacts', appId, 'users', userId, collectionName);
  };

  // Automatic 7-day cleanup
  const cleanupOldAttempts = useCallback(async () => {
    if (!user || !db) return;

    try {
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

      const attemptsRef = getUserDataPath('examAttempts');
      const oldAttemptsQuery = query(
        attemptsRef,
        where('timestamp', '<', sevenDaysAgo)
      );

      const snapshot = await getDocs(oldAttemptsQuery);
      
      if (snapshot.empty) {
        console.log('‚úÖ No old attempts to clean up');
        return;
      }

      console.log(`üßπ Found ${snapshot.size} attempts older than 7 days, deleting...`);

      const deletePromises = snapshot.docs.map(docSnapshot => 
        deleteDoc(doc(db, docSnapshot.ref.path))
      );

      await Promise.all(deletePromises);
      console.log(`‚úÖ Deleted ${snapshot.size} old exam attempts`);
    } catch (error) {
      console.error('‚ùå Error cleaning up old attempts:', error);
    }
  }, [user]);

  // Listen to exam attempts in real-time
  useEffect(() => {
    if (!user || !db) return;

    const q = query(
      getUserDataPath('examAttempts'), 
      orderBy('timestamp', 'desc')
    );
    
    const unsubscribe = onSnapshot(q, (snapshot) => {
      const attemptsByExam = {};
      
      snapshot.forEach(doc => {
        const attempt = doc.data();
        const examName = attempt.examName;
        
        if (!attemptsByExam[examName]) {
          attemptsByExam[examName] = [];
        }
        
        attemptsByExam[examName].push({ 
          ...attempt, 
          id: doc.id,
          hasReviewData: !!(attempt.questions && attempt.userAnswers)
        });
      });
      
      setQuizzes(attemptsByExam);
    }, (error) => {
      console.error('‚ùå Error fetching quiz attempts:', error);
    });

    // Run cleanup on mount
    cleanupOldAttempts();

    return () => unsubscribe();
  }, [user, cleanupOldAttempts]);

  // Add quiz attempt with COMPLETE data for review
  const addQuizAttempt = useCallback(async (examName, score, totalQuestions, timeSpent, questions, userAnswers) => {
    if (!user || !db) {
      console.error('‚ùå Cannot save: User not authenticated or DB unavailable');
      return;
    }

    try {
      const percentage = Math.round((score / totalQuestions) * 100);
      const passMark = EXAM_CONFIGS[examName]?.passMark || 70;
      
      const attemptData = {
        examName,
        score,
        totalQuestions,
        timeSpent,
        percentage,
        passed: percentage >= passMark,
        userId: user.uid,
        timestamp: serverTimestamp(),
        questions: questions || [],
        userAnswers: userAnswers || {}
      };
      
      await addDoc(getUserDataPath('examAttempts'), attemptData);
      
      console.log('‚úÖ Quiz attempt saved with full review data');
    } catch (error) {
      console.error('‚ùå Error saving exam attempt:', error);
      throw error;
    }
  }, [user]);

  // Delete individual exam attempt
  const deleteAttempt = useCallback(async (attemptId) => {
    if (!user || !db) {
      console.error('‚ùå Cannot delete: User not authenticated or DB unavailable');
      return;
    }

    if (!attemptId) {
      console.error('‚ùå Cannot delete: No attempt ID provided');
      return;
    }

    try {
      const userId = user.uid;
      const attemptRef = doc(db, 'artifacts', appId, 'users', userId, 'examAttempts', attemptId);
      
      await deleteDoc(attemptRef);
      console.log('‚úÖ Exam attempt deleted successfully');
    } catch (error) {
      console.error('‚ùå Error deleting exam attempt:', error);
      throw error;
    }
  }, [user]);

  return { 
    quizzes, 
    addQuizAttempt,
    deleteAttempt
  };
};