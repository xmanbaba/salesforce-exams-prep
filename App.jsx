import { useState, useCallback, useRef } from 'react';
import { Loader2, Zap } from 'lucide-react';

// Import custom hooks
import { useAuth } from './hooks/useAuth';
import { useFirestore } from './hooks/useFirestore';

// Import utilities
import { generateQuestions, randomizeQuestions } from './utils/questionUtils';
import { EXAM_CONFIGS } from './config/examConfig';

// Import components
import { AuthScreen } from './components/AuthScreen';
import { ExamSelection } from './components/ExamSelection';
import { Quiz } from './components/Quiz';
import { Results } from './components/Results';

function App() {
  // Auth and data hooks
  const { user, isAuthReady, signInWithGoogle, signInWithEmailPassword,
    createAccount, handleSignOut } = useAuth();
  const { quizzes, pausedExams, addQuizAttempt, deleteAttempt, 
    savePausedExam, loadPausedExam, deletePausedExam } = useFirestore(user);

  // Application state
  const [exam, setExam] = useState(null);
  const [currentPage, setCurrentPage] = useState('selection');
  const [questions, setQuestions] = useState([]);
  const [answers, setAnswers] = useState({});
  const [score, setScore] = useState(0);
  const [examStartTime, setExamStartTime] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [reviewMode, setReviewMode] = useState(null);
  
  // NEW: Pause/Resume state
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [timeLeft, setTimeLeft] = useState(null);
  const [isResuming, setIsResuming] = useState(false);
  
  // Track if quiz has been submitted to prevent duplicates
  const hasSubmittedRef = useRef(false);

  // Handle starting a quiz (regular or retake)
  const handleStartQuiz = useCallback((examName, newQuestions, isRetake = false) => {
    setExam(examName);

    const finalQuestions = isRetake ? randomizeQuestions(newQuestions || []) : (newQuestions || []);

    setQuestions(finalQuestions);
    setAnswers({});
    setScore(0);
    setCurrentQuestion(0);
    setExamStartTime(Date.now());
    setTimeLeft(EXAM_CONFIGS[examName].timeLimit * 60); // Set initial time
    setCurrentPage('quiz');
    setReviewMode(null);
    setIsResuming(false);
    hasSubmittedRef.current = false;
  }, []);

  // NEW: Handle resuming a paused exam
  const handleResumeExam = useCallback(async (pausedExam) => {
    try {
      setIsLoading(true);
      console.log(`📂 Resuming exam: ${pausedExam.examName}`);

      setExam(pausedExam.examName);
      setQuestions(pausedExam.questions);
      setAnswers(pausedExam.answers);
      setCurrentQuestion(pausedExam.currentQuestion);
      setTimeLeft(pausedExam.timeLeft);
      setExamStartTime(pausedExam.examStartTime);
      setIsResuming(true);
      setCurrentPage('quiz');
      setReviewMode(null);
      hasSubmittedRef.current = false;

      console.log(`✅ Resumed at question ${pausedExam.currentQuestion + 1} with ${pausedExam.timeLeft}s remaining`);
    } catch (error) {
      console.error('❌ Error resuming exam:', error);
      setError('Failed to resume exam. Please try again.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // NEW: Handle pausing exam
  const handlePauseExam = useCallback(async (currentQ, currentAnswers, currentTimeLeft) => {
    try {
      console.log(`⏸️ Pausing exam: ${exam} at question ${currentQ + 1}`);
      
      await savePausedExam(
        exam,
        currentQ,
        currentAnswers,
        currentTimeLeft,
        questions,
        examStartTime
      );

      alert('✅ Exam paused successfully! You can resume it from the dashboard.');
      setCurrentPage('selection');
    } catch (error) {
      console.error('❌ Error pausing exam:', error);
      alert('Failed to pause exam. Please try again.');
    }
  }, [exam, questions, examStartTime, savePausedExam]);

  // Handle generating questions from AI
  const handleGenerateQuestions = useCallback(async (examName, isRetake = false) => {
    setIsLoading(true);
    setError(null);

    try {
      const config = EXAM_CONFIGS[examName];
      console.log(`Starting question generation for ${examName}...`);

      const generatedQuestions = await generateQuestions(examName, config.questionCount);

      if (!generatedQuestions || generatedQuestions.length === 0) {
        throw new Error('No questions were generated by the AI');
      }

      if (generatedQuestions.length < config.questionCount) {
        console.warn(`Warning: Generated ${generatedQuestions.length} questions, expected ${config.questionCount}`);
      }

      console.log(`Successfully received ${generatedQuestions.length} questions`);
      handleStartQuiz(examName, generatedQuestions, isRetake);

    } catch (e) {
      console.error("Quiz generation failed:", e);

      let errorMessage = 'Failed to generate questions. ';

      if (e.message.includes('API key')) {
        errorMessage += 'API key is not configured. Please add your API keys to the .env file.';
      } else if (e.message.includes('429') || e.message.includes('rate limit')) {
        errorMessage += 'API rate limit exceeded. Please wait a few minutes and try again.';
      } else if (e.message.includes('400')) {
        errorMessage += 'API request error. Please verify your API key is valid and active.';
      } else if (e.message.includes('401') || e.message.includes('403')) {
        errorMessage += 'Authentication failed. Please check your API key permissions.';
      } else if (e.message.includes('network') || e.message.includes('fetch')) {
        errorMessage += 'Network error. Please check your internet connection and try again.';
      } else {
        errorMessage += e.message;
      }

      setError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [handleStartQuiz]);

  // Handle new quiz
  const handleNewQuiz = useCallback(async (examName) => {
    console.log(`Requesting new quiz for ${examName}`);
    await handleGenerateQuestions(examName, false);
  }, [handleGenerateQuestions]);

  // Handle quiz submission - FIXED TO PREVENT DUPLICATES
  const handleSubmitQuiz = useCallback(async () => {
    if (hasSubmittedRef.current) {
      console.log('⚠️ Quiz already submitted, ignoring duplicate submission');
      return;
    }

    hasSubmittedRef.current = true;
    console.log('📝 Processing quiz submission...');

    const finalScore = questions.reduce((acc, q, index) => {
      const userAnswer = answers[index];
      const correctAnswer = q.answer;
      
      if (q.questionType === 'multiple-select') {
        const userAnswers = (userAnswer || '').split(',').filter(Boolean).sort().join(',');
        const correctAnswers = correctAnswer.split(',').filter(Boolean).sort().join(',');
        if (userAnswers === correctAnswers) {
          return acc + 1;
        }
      } else {
        if (userAnswer === correctAnswer) {
          return acc + 1;
        }
      }
      return acc;
    }, 0);

    const timeSpent = Math.floor((Date.now() - examStartTime) / 1000);
    setScore(finalScore);

    if (user && addQuizAttempt) {
      try {
        await addQuizAttempt(exam, finalScore, questions.length, timeSpent, questions, answers);
        
        // Delete paused exam if it exists (since it's now completed)
        try {
          await deletePausedExam(exam);
        } catch (e) {
          // Ignore if no paused exam exists
        }
        
        console.log('✅ Quiz results saved successfully');
      } catch (error) {
        console.error('❌ Failed to save quiz results:', error);
      }
    }

    setCurrentPage('results');
  }, [answers, exam, questions, addQuizAttempt, deletePausedExam, user, examStartTime]);

  // Handle restart/retake quiz
  const handleRestartQuiz = useCallback(async () => {
    console.log(`Retaking exam: ${exam} - generating new questions`);
    await handleGenerateQuestions(exam, true);
  }, [exam, handleGenerateQuestions]);

  // Handle answer selection
  const handleAnswerChange = useCallback((qIndex, option) => {
    setAnswers(prev => ({ ...prev, [qIndex]: option }));
  }, []);

  // Handle reviewing past exam attempts
  const handleReviewPastExam = useCallback((attempt) => {
    if (!attempt.questions || !attempt.userAnswers) {
      alert('This exam attempt does not have detailed data available for review.');
      return;
    }
    
    setReviewMode(attempt);
    setExam(attempt.examName);
    setQuestions(attempt.questions);
    setAnswers(attempt.userAnswers);
    setScore(attempt.score);
    setExamStartTime(null);
    setCurrentPage('results');
  }, []);

  // Handle back to dashboard and clear review mode
  const handleBackToDashboard = useCallback(() => {
    setReviewMode(null);
    setCurrentPage('selection');
    hasSubmittedRef.current = false;
  }, []);

  // Render pages
  const renderPage = () => {
    if (!isAuthReady) {
      return (
        <div className="text-center p-8">
          <Loader2 className="animate-spin mx-auto mb-4" size={48} />
          <p className="text-xl font-semibold text-gray-600">Initializing Application...</p>
        </div>
      );
    }

    if (!user) {
      return (
        <AuthScreen
          signInWithGoogle={signInWithGoogle}
          signInWithEmailPassword={signInWithEmailPassword}
          createAccount={createAccount}
        />
      );
    }

    switch (currentPage) {
      case 'selection':
        return (
          <ExamSelection
            onStartQuiz={handleStartQuiz}
            quizzes={quizzes}
            pausedExams={pausedExams}
            isLoading={isLoading}
            error={error}
            generateQuestions={handleGenerateQuestions}
            onNewQuiz={handleNewQuiz}
            onReviewPastExam={handleReviewPastExam}
            onDeleteAttempt={deleteAttempt}
            onResumeExam={handleResumeExam}
            onDeletePausedExam={deletePausedExam}
          />
        );

      case 'quiz':
        return (
          <Quiz
            questions={questions}
            answers={answers}
            currentQuestion={currentQuestion}
            onCurrentQuestionChange={setCurrentQuestion}
            initialTimeLeft={timeLeft}
            onAnswerChange={handleAnswerChange}
            onSubmitQuiz={handleSubmitQuiz}
            onPauseExam={handlePauseExam}
            onBack={() => setCurrentPage('selection')}
            examName={exam}
            isResuming={isResuming}
          />
        );

      case 'results':
        return (
          <Results
            score={score}
            totalQuestions={questions.length}
            questions={questions}
            answers={answers}
            onBackToDashboard={handleBackToDashboard}
            onRestart={handleRestartQuiz}
            examName={exam}
            timeSpent={reviewMode ? reviewMode.timeSpent : Math.floor((Date.now() - examStartTime) / 1000)}
            isReviewMode={!!reviewMode}
          />
        );

      default:
        return null;
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4 md:p-8 font-sans">
      {/* Header */}
      <header className="flex justify-between items-center bg-white p-4 md:p-6 rounded-2xl shadow-xl mb-8">
        <h1 className="text-2xl md:text-3xl font-bold text-gray-800 flex items-center">
          <Zap className="text-blue-500 mr-2" size={30} />
          Salesforce Certification Prep
        </h1>

        {user && (
          <nav className="flex items-center space-x-4">
            <span className="text-sm text-gray-600 hidden sm:inline">
              {user.isAnonymous ? 'Guest User' : user.displayName || user.email}
            </span>

            {currentPage !== 'selection' && (
              <button
                onClick={() => {
                  setReviewMode(null);
                  setCurrentPage('selection');
                }}
                className="px-3 py-1.5 md:px-4 md:py-2 rounded-lg text-white bg-blue-600 hover:bg-blue-700 transition text-sm"
              >
                Dashboard
              </button>
            )}

            <button
              onClick={handleSignOut}
              className="px-3 py-1.5 md:px-4 md:py-2 rounded-lg text-white bg-red-500 hover:bg-red-600 transition text-sm"
            >
              Sign Out
            </button>
          </nav>
        )}
      </header>

      {/* Main Content */}
      <main>
        {renderPage()}
      </main>

      {/* Footer */}
      <footer className="mt-8 text-center text-gray-500 text-xs md:text-sm">
        <p>&copy; 2025 Salesforce Certification Prep - AI-Powered Learning Platform</p>
      </footer>
    </div>
  );
}

export default App;